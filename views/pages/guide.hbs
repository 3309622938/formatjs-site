{{setTitle "Guide"}}

<section class="head">
    {{> nav}}
</section>

<section class="main docs l-wrap">
    <h1>Guide</h1>


    <h2 id="principals">Basic Internationalization Principals</h2>


    <h3 id="what-and-why">What Is Internationalization and Why Does It Matter</h3>
    <p>
        Internationalized software is software that is designed to support the languages and cultural customs of people throughout the world.
        The Web reaches all parts of the world, and so web apps need to be internationalized in order to provide a great user experience for the most number of people.
    </p>

    <p>
        Localization of software is adapting the software for a specific language and culture.
        This involves translating text messages into the user's language and presenting data in a format consistent with the user's expectations.
        An app is typically localized for a small set of <a href="#locales">locales</a>.
    </p>

    <p>
        The <a href="http://www.ecma-international.org/ecma-402/1.0/index.html#sec-4.1">ECMA-402 javascript internalization specification</a> has an excellent overview.
    </p>


    <h3 id="locales">Locales: Language and Region</h3>
    <p>
        A "locale" is the language a user speaks and the cultural expectations for a region.
        It is represented using a "locale code" defined in <a href="http://tools.ietf.org/html/bcp47">BCP 47</a>.
    </p>

    <p>
        This code is comprised of several parts separated by hyphens ({{code "-"}}).
        The first part is a short string representing the language.
        The second, optional, part is a short string representing the region.
        In addition, various extensions and variants can be specified.
    </p>

    <p>
        Typically webapps are localized to just the language or language-region combination.
        Examples of such locale codes are...
        <ul>
            <li>{{code "en"}} for English</li>
            <li>{{code "en-US"}} English as spoken in the United States</li>
            <li>{{code "en-GB"}} English as spoken in the United Kingdom</li>
            <li>{{code "es-AR"}} for Spanish as spoken in Argentina</li>
            <li>{{code "ar-001"}} for Arabic as spoken throughout the world</li>
            <li>{{code "ar-AE"}} for Arabic as spoken in United Arab Emerates</li>
        </ul>
    </p>

    <p>
        Most internationalized apps only support a small list of locales.
    </p>


    <h3 id="translating-strings">Translating Strings</h3>
    <p>
        You likely have some text in your application that is in a natural language such as English or Chinese.
        In order to support other locales you'll need to translate these strings.
        You'll need to translate all strings for all locales you wish to support.
    </p>

    <p>
        {{brand}} provides a mechanism for using these translations.
        This lets you write the core "software" of your application without special code for different languages.
        The considerations for each locale are encapsulated in your translated strings and our libraries.
    </p>


    <h3 id="bundling-translations">Bundling Translated Strings</h3>
    <p>
        It is very common to organize your translations primarily by locale.
        This especially becomes important when using translations in the browser, where you only need the translations for one locale, the user's current locale.
    </p>

    <p>
        Our <a href="{{pathTo 'integrations'}}">template engine helpers</a> are designed to work with the translations for a single locale.
    </p>

    <p>
        (Translations can be further subdivided if your app is very complex, such as by page or section of the site.)
    </p>


    <h3 id="structure-code">Structure of Code</h3>
    <p>
        The actual formatting and presentation of data and translated strings typically takes these steps:
    </p>

    <ol>
        <li>
            Determine the user's locale, as described in <a href="#runtime-environments">Runtime Environments</a> below.
        </li>
        <li>
            Setup one of {{brand}}'s <a href="{{pathTo 'integrations'}}">template engine helpers</a> with the following data:
            <ul>
                <li>the user's current locale</li>
                <li>translated strings for that locale</li>
                <li>optionally, any <a href="#TODO">custom formats</a></li>
            </ul>
        </li>
        <li>
            Call the template engine, passing the data that needs formatting.
        </li>
    </ol>


    <h2 id="patch-runtime">Patching the Runtime for Internationalization Support</h2>
    <p>
        The {{brand}} libraries rely on the following <a href="http://www.ecma-international.org/ecma-402/1.0/index.html">ECMA 402</a> internationalization APIs:
    </p>

    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat">{{code "Intl.NumberFormat"}}</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat">{{code "Intl.DateTimeFormat"}}</a></li>
    </ul>

    <p>
        The {{code "Intl"}} API is available on all modern browsers except Safari.
        It is not available on mobile browsers nor node.js.
        See the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Browser_Compatibility">MDN documentation</a> for an up-to-date list of capable browsers.
    </p>

    <p>
        If these APIs aren't present you'll need to patch (polyfill) your runtime to include them.
    </p>


    <h3 id="how-to-patch">How to Patch</h3>
    <p>
        Since some runtimes already have {{code "Intl"}}, ideally you'll only load a patch when needed.
        You can do this using a conditional loader.
    </p>

    <p>
        One conditional loader is <a href="http://yepnopejs.com/">yepnopejs</a>.
        Here's an example of how to use it:
    </p>

{{#code lang="js"}}
yepnope({
    test : window.Intl,
    nope : ['path/to/intl/polyfill'],
    complete: function() {
        ...the Intl API can be used here...
    }
});
{{/code}}


    <h3 id="intljs">Intl.js Polyfill</h3>
    <p>
        The <a href="https://github.com/andyearnshaw/Intl.js">Intl.js</a> library provides a polyfill for the {{code "Intl"}} API.
        It will need a locale data file loaded for the locale of the current page.
    </p>

{{#code lang="html"}}
<script src="path/to/intl/Intl.js"></script>
<script src="path/to/intl/locale-data/jsonp/en.js"></script>
...use the locale for the current user instead of "en".
{{/code}}

    <p>
        In node.js the library contains data for all locales.
    </p>

{{#code lang="js"}}
var Intl = require('intl');
{{/code}}

    <p class="note">
        <strong>Note</strong> that the {{code "Intl.js"}} polyfill doesn't have the {{code "Intl.Collator"}} API.
    </p>


    <h2 id="runtime-environments">Runtime Environments</h2>
    <p>
        Here is information on how to setup {{brand}} in different environments.
    </p>


    <h3 id="server-side">Server</h3>
    <p>
        In node.js our libraries are available as NPM packages.
        Each of our <a href="{{pathTo "integrations"}}">template engine helpers</a> has details on how they are installed.
    </p>

    <p>
        Node (as of 0.10) doesn't provide the global {{code "Intl"}} object.
        You'll need to <a href="#how-to-patch">provide a polyfill</a> as described above.
    </p>


    <h4 id="user-locale-server">Determining the User's Locale</h4>
    <p>
        When a request comes in you'll need to determine the locale for the response.
        Best practice is to provide the user an explicit way of choosing one of the locales your app supports
        (and persisting that choice in a user profile database).
    </p>

    <p>
        If you wish to programmatically infer the user's locale you can inspect the <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Accept-Language">{{code "Accept-Language"}}</a> HTTP request header.
        (This is part of HTTP <a href="http://en.wikipedia.org/wiki/Content_negotiation">content negotiation</a>.)
        There are <a href="https://www.npmjs.org/search?q=accept-language">NPM modules</a> that can help with this, {{npmLink "accepts"}} and {{npmLink "negotiator"}} being two good choices.
        As well, express has some content negotion <a href="http://expressjs.com/4x/api.html#req.acceptsLanguages">built in</a>.
    </p>

{{#code lang="js"}}
var appLocales = ['de', 'en', 'fr'];
var app = require('express')();
app.get('/', function(req, res) {
    var locale = req.acceptsLanguages(appLocales) || 'en';
    ...customize the response to locale
});
{{/code}}


    <h3 id="client-side">Client</h3>
    <p>
        Each of our <a href="{{pathTo "integrations"}}">template engine helpers</a> has details on how to load them into the browser.
    </p>

    <p>
        If the browser doesn't support the {{code "Intl"}} API you'll need to <a href="#how-to-patch">provide a polyfill</a> as described above.
        The polyfill you choose might require you to load a separate file for each locale.
        In this caes you can dynamically load a single locale file based on the user's locale.
    </p>


    <h4 id="user-locale-client">Determining the User's Locale</h4>
    <p>
        When running internationalization code in the browser it is best if the locale used is the same as was used when the page was generated.
        You can do this by having the server embed the chosen locale into the generate page.
        This ensures that the user gets a consistent experience and that the UI doesn't suddenly "switch languages" on them.
    </p>

    <p>
        If this isn't possible or if you have a single-page application which is served statically,
        the best practice is to provide the user an explicit way to choose one of the locales your app supports.
        If you wish to programmatically infer the user's locale you can match {{code "navigator.language || navigator.browserLanguage"}} against the locales your app supports.
    </p>


    <h2 id="messageformat-syntax">Message Format Syntax</h2>
<!--
    * standard
        * ICU (used in java, php, objective-c)
    * basic principals
        * text (or text element)
        * argument
    * simple argument
        * syntax
    * formatted arguments ({x, number}, {x, date}, and {x, time})
        * syntax
        * predefined options
            * for each type
        * creating your own options
    * {select} format
        * syntax
        * matching rules
        * nesting
    * {plural} format
        * syntax very similar to {select}
        * pluralization groups (link to CLDR page)
        * offset
        * specific value matches ('=43')
-->


</section>
